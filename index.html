<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<!-- 모바일 뷰포트 설정 (GAS doGet에서 처리하던 부분) -->
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>단단타로 Ver.3</title>
<link rel="icon" href="favicon.ico" type="image/x-icon">
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>

<style>
  :root{
    /* --- 기본 테마 색상 --- */
    --bg:#0f1115;
    --panel:#171a21;
    --ink:#e7eaf0;
    --muted:#a7b0bf;
    --stroke:#2a2f3a;
    --link:#9cc1ff;
    --danger:#ff375f;
    --frame:#e6edf5;

    /* =========================================================
       ✅ 스타일 커스터마이징 영역
       ========================================================= */

    /* --- 앱 레이아웃 --- */
    --app-width: 1400px; /* 앱 전체 기준 폭 */
    --memo-width: 420px; /* 메모장 너비 */
    --memo-min-height: 720px; /* 메모장 최소 높이 */

    /* --- 대기열 (Queue) 레이아웃 설정 --- */
    --queue-width: 280px;      /* 대기열 박스 너비 (기본값) */
    --queue-height: 300px;     /* 대기열 박스 높이 (기본값) */
    --queue-bg: rgba(23, 26, 33, 0.1); /* 배경색 (반투명) */
    --queue-z-index: 9000;     /* 레이어 순서 (상단) */
    
    --queue-font-base: 15px;   /* 기준 폰트 크기 (기본값) */
    --queue-title-font-size: calc(var(--queue-font-base) + 5px);       /* 12+3 = 15px */
    --queue-status-font-size: calc(var(--queue-font-base) + 3px);      /* 12+1 = 13px */
    --queue-table-header-font-size: var(--queue-font-base);            /* 12px */

    /* [환경설정] 크기 조절 단위 (한 단계당 늘어나는 양) */
    --step-width: 30px;        /* 가로 증가량 */
    --step-height: 40px;       /* 세로 증가량 */
    --step-font-size: 2px;     /* 폰트 증가량 */

    /* --- 1. 기본 버튼 스타일 (Default) --- */
    /* 모든 버튼에 공통으로 적용되는 기본값입니다. */
    --btn-default-bg: #131722;
    --btn-default-fg: #e5ecff;
    --btn-default-border: var(--stroke);
    --btn-default-font-weight: 900;
    --btn-default-font-size: 16px;
    --btn-default-height: 38px;
    --btn-default-radius: 12px;
    --btn-default-padding: 0 14px;

    /* --- 2. 개별 버튼 스타일 --- */
    /* 기본값을 그대로 사용하려면 이 섹션을 수정할 필요가 없습니다. */
    /* 특정 버튼만 바꾸고 싶을 때, 아래 '--btn-default-...' 부분을 원하는 값으로 바꾸세요. */

    /* -- #resetBtn (RESET) -- */  
    --btn-reset-bg: #85202a;
    --btn-reset-fg: var(--btn-default-fg);
    --btn-reset-border: var(--btn-default-border);
    --btn-reset-font-weight: var(--btn-default-font-weight);
    --btn-reset-font-size: var(--btn-default-font-size);
    --btn-reset-height: var(--btn-default-height);
    --btn-reset-radius: var(--btn-default-radius);
    --btn-reset-padding: var(--btn-default-padding);

    /* -- #decideBtn (결정) -- */
    --btn-decide-bg: #2cc781;
    --btn-decide-fg: var(--btn-default-fg);
    --btn-decide-border: var(--btn-default-border);
    --btn-decide-font-weight: var(--btn-default-font-weight);
    --btn-decide-font-size: var(--btn-default-font-size);
    --btn-decide-height: var(--btn-default-height);
    --btn-decide-radius: var(--btn-default-radius);
    --btn-decide-padding: var(--btn-default-padding);

    /* -- #pickBtn (폴더선택) -- */
    --btn-pick-bg: var(--btn-default-bg);
    --btn-pick-fg: var(--btn-default-fg);
    --btn-pick-border: var(--btn-default-border);
    --btn-pick-font-weight: var(--btn-default-font-weight);
    --btn-pick-font-size: var(--btn-default-font-size);
    --btn-pick-height: var(--btn-default-height);
    --btn-pick-radius: var(--btn-default-radius);
    --btn-pick-padding: var(--btn-default-padding);

    /* -- #nextBtn (다음) -- */
    --btn-next-bg: var(--btn-default-bg);
    --btn-next-fg: var(--btn-default-fg);
    --btn-next-border: var(--btn-default-border);
    --btn-next-font-weight: var(--btn-default-font-weight);
    --btn-next-font-size: var(--btn-default-font-size);
    --btn-next-height: var(--btn-default-height);
    --btn-next-radius: var(--btn-default-radius);
    --btn-next-padding: var(--btn-default-padding);

    /* -- #memoToggle (메모장 켜기/끄기) -- */
    --btn-memo-bg: var(--btn-default-bg);
    --btn-memo-fg: var(--btn-default-fg);
    --btn-memo-border: var(--btn-default-border);
    --btn-memo-font-weight: var(--btn-default-font-weight);
    --btn-memo-font-size: 14px; /* 기본값과 다르게 설정 */
    --btn-memo-height: 32px;    /* 기본값과 다르게 설정 */
    --btn-memo-radius: var(--btn-default-radius);
    --btn-memo-padding: 0 10px; /* 기본값과 다르게 설정 */

    /* -- #viewAllCardsBtn (카드만보기) -- */
    --btn-view-all-cards-bg: var(--btn-default-bg);
    --btn-view-all-cards-fg: var(--btn-default-fg);
    --btn-view-all-cards-border: var(--btn-default-border);
    --btn-view-all-cards-font-weight: var(--btn-default-font-weight);
    --btn-view-all-cards-font-size: var(--btn-default-font-size);
    --btn-view-all-cards-height: var(--btn-default-height);
    --btn-view-all-cards-radius: var(--btn-default-radius);
    --btn-view-all-cards-padding: var(--btn-default-padding);

    /* -- .remove (카드 제거) -- */
    --btn-danger-bg: var(--danger);
    --btn-danger-fg: #fff;
    --btn-danger-font-weight: 900;
    --btn-danger-size: 24px; /* 사이즈 조절 */

    /* ========================================================= */
    /* ... */
  } /* :root 닫기 */

  *{box-sizing:border-box}
  html,body{
    height:100%; margin:0; background:var(--bg); color:var(--ink);
    font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Noto Sans,"Apple SD Gothic Neo","Malgun Gothic",sans-serif;
  }

  /* 앱 컨테이너: 기준 폭으로 가운데 정렬 */
  .app{
    position:relative;
    width:var(--app-width);
    min-height:100vh;
    margin:0 auto;
    padding:16px 16px 96px;
    display:grid;
    grid-template-columns:minmax(0,1fr) var(--MEMO_COL);
    gap:16px;
    transition:grid-template-columns .25s ease, width .25s ease;
  }

  /* ===== 컨트롤: 2줄, 가운데 정렬 ===== */
  .controls{display:flex; flex-direction:column; gap:8px; margin-bottom:24px; align-items:center}
  .controls-row{display:flex; align-items:center; gap:12px; justify-content:center}
  .status-box{
    display:inline-flex; align-items:center; gap:8px;
    padding:6px 10px; border-radius:10px; background:rgba(255,255,255,.18); color:#fff;
    font-size:22px; font-weight:800; cursor:pointer;
  }
  .mini-spin{width:14px;height:14px;border-radius:50%;border:2px solid rgba(0,0,0,.25);border-top-color:#000;display:none;animation:spin .9s linear infinite}
  .mini-spin.on{display:inline-block}
  @keyframes spin{to{transform:rotate(360deg)}}

  /* .skewed 공통 구조 스타일 */
  .skewed{
    min-width:108px;
    letter-spacing:.02em;
    /* transform:skewX(-16deg); */ /* 마름모 형태 제거 */
    cursor:pointer;
    border: none; /* 테두리는 각 버튼에서 정의 */
  }
  .skewed > span{ display: inline-block; /* transform: skewX(16deg); */ }

  /* 각 버튼별 개별 스타일 적용 */
  #resetBtn, #decideBtn, #pickBtn, #nextBtn, #memoToggle {
    display: inline-block;
  }

  #resetBtn {
    height: var(--btn-reset-height);
    padding: var(--btn-reset-padding);
    border: 1px solid var(--btn-reset-border);
    border-radius: var(--btn-reset-radius);
    background: var(--btn-reset-bg);
    color: var(--btn-reset-fg);
    font-weight: var(--btn-reset-font-weight);
    font-size: var(--btn-reset-font-size);
  }
  #decideBtn {
    height: var(--btn-decide-height);
    padding: var(--btn-decide-padding);
    border: 1px solid var(--btn-decide-border);
    border-radius: var(--btn-decide-radius);
    background: var(--btn-decide-bg);
    color: var(--btn-decide-fg);
    font-weight: var(--btn-decide-font-weight);
    font-size: var(--btn-decide-font-size);
  }
  #pickBtn {
    height: var(--btn-pick-height);
    padding: var(--btn-pick-padding);
    border: 1px solid var(--btn-pick-border);
    border-radius: var(--btn-pick-radius);
    background: var(--btn-pick-bg);
    color: var(--btn-pick-fg);
    font-weight: var(--btn-pick-font-weight);
    font-size: var(--btn-pick-font-size);
  }
  #nextBtn {
    height: var(--btn-next-height);
    padding: var(--btn-next-padding);
    border: 1px solid var(--btn-next-border);
    border-radius: var(--btn-next-radius);
    background: var(--btn-next-bg);
    color: var(--btn-next-fg);
    font-weight: var(--btn-next-font-weight);
    font-size: var(--btn-next-font-size);
  }
  #memoToggle {
    min-width: auto;
    height: var(--btn-memo-height);
    padding: var(--btn-memo-padding);
    border: 1px solid var(--btn-memo-border);
    border-radius: var(--btn-memo-radius);
    background: var(--btn-memo-bg);
    color: var(--btn-memo-fg);
    font-weight: var(--btn-memo-font-weight);
    font-size: var(--btn-memo-font-size);
  }
  #viewAllCardsBtn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    text-decoration: none;
    height: var(--btn-view-all-cards-height);
    padding: var(--btn-view-all-cards-padding);
    border: 1px solid var(--btn-view-all-cards-border);
    border-radius: var(--btn-view-all-cards-radius);
    background: var(--btn-view-all-cards-bg);
    color: var(--btn-view-all-cards-fg);
    font-weight: var(--btn-view-all-cards-font-weight);
    font-size: var(--btn-view-all-cards-font-size);
  }
  .search-wrap{position:relative; width:260px; flex:0 0 260px}
  .search-input{width:100%; padding:10px 12px; border-radius:12px; border:1px solid var(--stroke);
    background:#0c0f14; color:#fff; font-size:15px; outline:none;}
  .dropdown{position:absolute; left:0; right:0; top:100%; margin-top:6px; z-index:20;
    background:#0c0f14; border:1px solid var(--stroke); border-radius:12px; display:none; max-height:300px; overflow:auto;}
  .dropdown.show{display:block}
  .opt{padding:10px 12px; display:flex; justify-content:space-between; gap:8px; font-size:14px; cursor:pointer; border-bottom:1px solid rgba(255,255,255,.04)}
  .opt.disabled{opacity:.35; pointer-events:none}
  .opt:hover,.opt.active{background:#131722}

  .flip{position:relative; width:210px; height:44px; border-radius:12px; border:1px solid var(--stroke);
    background:#0c0f14; display:flex; align-items:center; user-select:none; font-weight:900; font-size:15px; flex:0 0 210px}
  .flip input{display:none}
  .flip .track{position:absolute; inset:4px; border-radius:10px; background:#10141c; display:flex; overflow:hidden;}
  .flip .seg{flex:1; display:flex; align-items:center; justify-content:center; z-index:1; color:#9fb0c7}
  .flip .thumb{position:absolute; top:4px; bottom:4px; left:4px; width:calc(50% - 4px);
    border-radius:10px; background:#b6f7c1; color:#0a2012; display:flex; align-items:center; justify-content:center; transition:left .2s ease}
  .flip input:checked ~ .thumb{left:calc(50% + 0px); background:#d7b6f7; color:#1a0f22}

  /* ===== 보드 & 카드 ===== */
  .board{display:grid; grid-template-columns:repeat(auto-fill, minmax(250px,1fr)); gap:14px; align-content:start;}
  .cardItem{user-select:none}
  .cardBox{display:flex; flex-direction:column; align-items:center; gap:8px; transition:transform .15s ease}
  .cardItem:hover .cardBox{transform:scale(1.05)}

  .card{width:250px; height:400px; cursor:pointer; border:2px dashed #2b303b; border-radius:14px;
        background:#0c0f14 center/cover no-repeat; transition:transform .25s ease; position:relative; z-index:10}
  .card.has-img{ border:none; }        
  .card.rev{transform:rotate(180deg)}
  .cap-row{width:250px; display:flex; align-items:center; justify-content:space-between; gap:8px}
  .cap{flex:1 1 auto; text-align:center; font-weight:700; font-size:18px; color:#cdd5e3; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}

  .remove{
    flex:0 0 auto;
    width:var(--btn-danger-size);
    height:var(--btn-danger-size);
    border-radius:4px; /* 둥근 사각형 */
    border:none;
    background:transparent; /* 배경 투명 */
    color:var(--danger); /* 아이콘 색상 */
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    transition: background .2s, color .2s;
  }
  .remove:hover {
    background: rgba(255, 55, 95, 0.15); /* 호버 시 붉은색 틴트 */
  }
  .remove svg {
    width: 18px;
    height: 18px;
    fill: currentColor;
    stroke: currentColor;
    stroke-width: 2;
  }

  /* ===== 메모장 ===== */
  .memo{
    background:#171a21; border:1px solid var(--stroke); border-radius:14px; padding:12px; display:flex; flex-direction:column;
    min-height: var(--memo-min-height);
  }
  .memo .memo-body{display:block}
  .memo textarea{
    height: var(--memo-min-height);
    min-height: var(--memo-min-height);
    flex: 0 0 var(--memo-min-height);
    width:100%;
    resize:none;
    background:#0c0f14;
    border:1px solid var(--stroke);
    border-radius:12px;
    color:#fff;
    font-size:24px;
    line-height:1.4;
    padding:10px;
    overflow-y:auto;
  }

  /* 접힘: 보드 풀폭, 버튼 우상단 도킹 */
  .memo.collapsed{
    position:absolute; right:16px; top:16px; width:auto;
    padding:0; border:none; background:transparent;
    min-height: 0;
  }
  .memo.collapsed .memo-body, .memo.collapsed h3{display:none}
  .memo.collapsed .memo-header{display:block}

  /* ===== 타이틀 ===== */
  .veil{position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:9999; background:rgba(0,0,0,.66); backdrop-filter: blur(14px)}
  .veil.hide{display:none}
  .modal{width:1100px; padding:40px 24px; border-radius:16px; border:1px solid var(--stroke); background:#0c0f14}
  .modal-grid{ display:grid; grid-template-columns:520px auto; gap:24px; align-items:start; }

  .preview{width:500px; height:500px; margin:0 auto 12px; border-radius:12px; background:#0c0f14}
  .preview img{width:100%; height:100%; object-fit:contain}

  .intro-box{ display:inline-block; background:#121723; border:1px solid #2a3342; border-radius:12px; padding:14px; max-width:600px; max-height:500px; }
  .intro-title{margin:0 0 8px 0; font-weight:800; color:#cfe2ff; letter-spacing:.02em}
  .intro-read{display:inline-block; width:fit-content; max-width:560px; max-height:430px;
    margin:0; padding:8px 4px 6px 0; background:transparent; border:none;
    color:#e9eefb; font-size:14px; line-height:1.5;
    white-space:normal; overflow-x:hidden; overflow-y:auto; word-break:keep-all; overflow-wrap:break-word;}
  .intro-read p{margin:.4rem 0}
  .intro-read a{color:#9cc1ff; text-decoration:underline}
  .intro-read img{max-width:100%; height:auto; border-radius:6px; display:inline-block}

  .pickerRow{display:flex; align-items:center; gap:12px; margin-top:18px}
  .pickerRow .grow{flex:1}
  .spinner{width:18px; height:18px; border-radius:50%; border:3px solid #3a4456; border-top-color:#9cc1ff; animation:spin .9s linear infinite; display:none}
  .spinner.on{display:inline-block}

  /* ===== 라이트박스(프레임+캡션, 배율 연동) ===== */
  #cardOverlay.veil{background:rgba(0,0,0,.78); z-index:10003}
  .lightWrap{
    --fs-scale:1; /* JS에서 동적으로 세팅 (캡션 폰트/패딩 스케일) */
    border:2px solid var(--frame); border-radius:18px;
    background:linear-gradient(180deg,#0b0f16,#0a1018 60%,#0a0e14);
    box-shadow:0 14px 60px rgba(0,0,0,.6); overflow:hidden;
    display:flex; flex-direction:column; align-items:stretch;
  }
  .lightImg{width:100%; height:100%; object-fit:contain; background:#080c12}
  .lightCap{
    padding:calc(10px * var(--fs-scale)) calc(14px * var(--fs-scale));
    border-top:1px solid rgba(230,237,245,.15);
    text-align:center; color:#e9ecff; letter-spacing:.02em; font-weight:900;
    font-size:clamp(14px, calc(16px * var(--fs-scale)), 28px);
  }

  /* ===== 대기열 (Queue) UI ===== */
  .queue-box {
    position: fixed;
    /* 기본 위치 (JS에서 클래스로 제어하므로 초기값은 무시되거나 pos-bl로 덮어씌워짐) */
    left: 16px; 
    bottom: 16px;
    width: var(--queue-width);
    height: var(--queue-height);
    background: var(--queue-bg);
    border: 1px solid var(--stroke);
    border-radius: 14px;
    z-index: var(--queue-z-index);
    display: flex;
    flex-direction: column;
    box-shadow: 0 4px 20px rgba(0,0,0,0.4);
    /* overflow: hidden; -> 팝업 노출을 위해 제거 */
    backdrop-filter: blur(6px);
    transition: top .3s, bottom .3s, left .3s, right .3s; /* 부드러운 이동 */
  }

  /* 위치 클래스 */
  .queue-box.pos-bl { left: 16px; bottom: 16px; top: auto; right: auto; }
  .queue-box.pos-tl { left: 16px; top: 16px; bottom: auto; right: auto; }
  /* 오른쪽 위: 메모장 너비(--MEMO_COL) + 기본 여백(16px) 만큼 떨어짐 */
  .queue-box.pos-tr { right: calc(var(--MEMO_COL) + 16px); top: 16px; bottom: auto; left: auto; }
  .queue-box.pos-br { right: 16px; bottom: 16px; top: auto; left: auto; }

  .queue-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 14px;
    background: rgba(255,255,255,0.03);
    border-bottom: 1px solid var(--stroke);
    border-radius: 14px 14px 0 0; /* 상단 모서리 둥글게 복구 */
  }
  .queue-title {
    flex-grow: 1;
    text-align: center;
    font-weight: 800;
    font-size: var(--queue-title-font-size);
    color: #fff;
    letter-spacing: -0.02em;
  }
  .queue-tools {
    display: flex;
    gap: 6px;
  }
  .icon-btn {
    background: transparent;
    border: none;
    color: #fff;
    padding: 4px;
    cursor: pointer;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: color 0.2s, background 0.2s;
  }
  .icon-btn:hover {
    background: rgba(255,255,255,0.1);
  }
  .icon-btn svg {
    width: 16px;
    height: 16px;
    fill: currentColor;
  }
  .queue-status {
    padding: 10px 14px;
    font-size: var(--queue-status-font-size);
    color: #fff; /* 흰색으로 변경 */
    border-bottom: 1px solid rgba(255,255,255,0.15);
    display: flex;
    justify-content: center;
    gap: 6px;
    align-items: center;
  }
  .queue-val {
    font-weight: 700;
    color: var(--link);
    font-size: 14px;
  }
  .queue-body {
    flex: 1;
    overflow-y: auto;
    padding: 0;
  }
  
  .queue-table {
    width: 100%;
    border-collapse: collapse;
    font-size: var(--queue-font-base); /* 기준 폰트 적용 */
    text-align: center;
  }
  .queue-table th {
    position: sticky;
    top: 0;
    background: var(--queue-bg); /* queue-bg 값 적용 */
    color: #fff; /* 흰색으로 변경 */
    padding: 8px 4px;
    font-weight: 600;
    font-size: var(--queue-table-header-font-size);
    border-bottom: 1px solid rgba(255,255,255,0.15);
  }
  .queue-table td {
    padding: 6px 4px;
    border-bottom: 1px solid rgba(255,255,255,0.1);
    color: #fff; /* 흰색으로 변경 */
  }
  .queue-table tr:last-child td {
    border-bottom: none;
  }
  
  /* 설정 팝업 스타일 */
  .queue-settings {
    position: absolute;
    /* 기본값 (Bottom-Left 기준): 박스 위쪽, 왼쪽 정렬 */
    bottom: 100%;      
    top: auto;         
    left: 0;           
    right: auto;
    margin-bottom: 10px; 
    margin-top: 0;
    margin-left: 0;    
    width: 220px;
    background: #1b1f29;
    border: 1px solid var(--stroke);
    border-radius: 12px;
    padding: 12px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.5);
    display: none; 
    flex-direction: column;
    gap: 10px;
    z-index: 9001;
  }
  .queue-settings.show { display: flex; }
  
  /* 말풍선 꼬리 기본 (아래쪽을 향함) */
  .queue-settings::before {
    content: "";
    position: absolute;
    top: 100%;         
    bottom: auto;
    left: 20px;
    right: auto;
    width: 10px;
    height: 10px;
    background: #1b1f29;
    border: 1px solid var(--stroke);
    border-top: none; border-left: none; /* 우하단 테두리 */
    transform: rotate(45deg);
    margin-top: -6px; 
    margin-bottom: 0;
  }

  /* 위치별 팝업 조정 */
  /* Top에 붙으면 팝업은 아래로 */
  .queue-box.pos-tl .queue-settings,
  .queue-box.pos-tr .queue-settings {
    bottom: auto;
    top: 100%;
    margin-bottom: 0;
    margin-top: 10px;
  }
  /* Top일 때 꼬리는 위쪽을 향함 */
  .queue-box.pos-tl .queue-settings::before,
  .queue-box.pos-tr .queue-settings::before {
    top: auto;
    bottom: 100%;
    border: 1px solid var(--stroke);
    border-bottom: none; border-right: none; /* 좌상단 테두리 */
    margin-top: 0;
    margin-bottom: -6px;
  }

  /* Right에 붙으면 팝업은 오른쪽 정렬 */
  .queue-box.pos-tr .queue-settings,
  .queue-box.pos-br .queue-settings {
    left: auto;
    right: 0;
  }
  /* Right일 때 꼬리는 오른쪽으로 이동 */
  .queue-box.pos-tr .queue-settings::before,
  .queue-box.pos-br .queue-settings::before {
    left: auto;
    right: 20px;
  }


  .qs-row { 
    display: flex; 
    align-items: center; 
    justify-content: space-between; 
    font-size: 13px; 
    color: #fff; /* 흰색으로 변경 */
    padding-bottom: 8px; /* 구분선 위아래 패딩 */
    margin-bottom: 8px; /* 구분선 위아래 마진 */
    border-bottom: 1px solid rgba(255,255,255,0.08); /* 구분선 */
  }
  .qs-row:last-child {
    border-bottom: none; /* 마지막 줄 구분선 제거 */
    margin-bottom: 0;
    padding-bottom: 0;
  }
  .qs-label { 
    font-weight: 600; 
    flex: 0 0 50px; 
    text-align: center; /* 라벨 중앙 정렬 */
  }
  
  /* 컨트롤 박스 (공통) */
  .qs-font-ctrl { 
    display: flex; 
    align-items: center; 
    justify-content: center; /* 컨트롤 중앙 정렬 */
    gap: 8px; 
    background: #0c0f14; 
    padding: 2px; 
    border-radius: 6px; 
    border: 1px solid var(--stroke); 
  }
  .qs-btn { width: 24px; height: 24px; background: transparent; border: none; color: #fff; cursor: pointer; font-weight: bold; display: grid; place-items: center; }
  .qs-btn:hover { background: rgba(255,255,255,0.1); border-radius: 4px; }
  .qs-val { font-variant-numeric: tabular-nums; width: 40px; text-align: center; font-size: 13px; }

  /* 마감 배지 스타일 */
  .badge-closed {
    display: inline-block;
    padding: 4px 8px;
    background: var(--danger); /* 붉은색 */
    color: #fff;
    border-radius: 8px;
    font-size: 0.9em;
    font-weight: 800;
    line-height: 1;
  }

  /* 일반 상태 배지 스타일 (현재: [값] [값]) */
  .status-badge {
    display: inline-block;
    padding: 4px 8px;
    background: rgba(255, 255, 255, 0.15); /* 반투명 회색 */
    color: #fff;
    border-radius: 8px;
    font-size: 0.9em;
    font-weight: 700;
    line-height: 1;
    margin: 0 2px;
  }

</style>
</head>

<body>
  <div class="app" id="appRoot">
    <section class="left">
      <div class="controls">
        <!-- 1줄: 상태 -->
        <div class="controls-row top">
          <div id="statusBox" class="status-box" title="클릭하여 갱신">
            <span class="label">현재 :</span>
            <span id="statusVal" class="val"></span>
            <span id="statusSpinner" class="mini-spin"></span>
          </div>
        </div>
        <!-- 2줄: RESET / 검색 / 정역 / 결정 -->
        <div class="controls-row bottom">
          <button id="resetBtn" class="skewed" type="button" disabled>RESET</button>

          <div class="search-wrap">
            <input id="search" class="search-input" type="text" placeholder="검색: 영문/한글 일부 일치" autocomplete="off" />
            <div id="dropdown" class="dropdown"></div>
          </div>

          <label class="flip" title="정방향 / 역방향">
            <input id="rev" type="checkbox" />
            <div class="track"><div class="seg">정방향</div><div class="seg">역방향</div></div>
            <div class="thumb" id="flipThumb">정방향</div>
          </label>

          <button id="decideBtn" class="skewed" type="button"><span>결정</span></button>
        </div>
      </div>

      <div id="board" class="board"></div>
    </section>

    <!-- 메모장 (기본: 접힘 / 버튼은 앱 우상단 도킹) -->
    <aside class="memo collapsed" id="memo">
      <div class="memo-header" style="display:flex; align-items:center; justify-content:space-between; gap:8px;">
        <h3 style="margin:0">메모장</h3>
        <button id="memoToggle" class="skewed small" type="button" aria-pressed="true">메모장 열기</button>
      </div>
      <div class="memo-body">
        <textarea placeholder="자유롭게 메모하세요. (서버 저장 없음)"></textarea>
      </div>
    </aside>
  </div>

  <!-- ===== 대기열 UI (Left Bottom Fixed) ===== -->
  <aside id="queueBox" class="queue-box">
    <!-- 1줄: 타이틀 + 도구버튼 -->
    <div class="queue-header">
      <span class="queue-title">타로데이 대기열</span>
      <div class="queue-tools">
        <!-- 위치 이동 버튼 -->
        <button type="button" class="icon-btn" title="위치 이동" id="queuePosBtn">
          <svg viewBox="0 0 24 24"><path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h10v4h8v10z"/></svg>
        </button>
        <!-- 설정 아이콘 (Settings) -->
        <button type="button" class="icon-btn" title="설정" id="queueSettingBtn">
          <svg viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
        </button>
      </div>
    </div>

    <!-- 2줄: 상태 -->
    <div class="queue-status">
      <span>현재 대기열:</span>
      <span id="queueCurrentCount" class="queue-val"></span>
      <span id="queueSpinner" class="mini-spin"></span>
    </div>

    <!-- 3줄: 테이블 헤더 + 바디 -->
    <div class="queue-body">
      <table class="queue-table">
        <thead>
          <tr>
            <th width="20%">순번</th>
            <th>닉네임</th>
            <th width="30%">타로종류</th>
          </tr>
        </thead>
        <tbody id="queueTableBody">
          <!-- 데이터 들어올 자리 (비워둠) -->
        </tbody>
      </table>
    </div>

    <!-- 설정 팝업 -->
    <div id="queueSettings" class="queue-settings">
      <div class="qs-row" style="border-bottom: none;">
        <span class="qs-label">크기</span>
        <div class="qs-font-ctrl">
          <button type="button" class="qs-btn" id="qsScaleMinus">-</button>
          <span id="qsScaleVal" class="qs-val">기본</span>
          <button type="button" class="qs-btn" id="qsScalePlus">+</button>
        </div>
      </div>
    </div>
  </aside>

  <!-- ===== 타이틀(소개/Log/폴더 검사 UI) ===== -->
  <div id="veil" class="veil">
    <div class="modal">
      <!-- 소개글 / Log 토글 -->
      <div style="display:flex; justify-content:space-between; align-items:center; margin:-12px 0 8px;">
        <a href="./all_cards.html" id="viewAllCardsBtn" class="skewed" target="_blank"><span>카드만보기</span></a>
        <label class="flip" style="width:260px; height:44px;">
          <input id="readFlip" type="checkbox" />
          <div class="track"><div class="seg">소개글</div><div class="seg">Log</div></div>
          <div class="thumb" id="readThumb">소개글</div>
        </label>
      </div>

      <div class="modal-grid">
        <div id="preview" class="preview"><img id="titleImg" alt="title"></div>

        <div class="intro-box">
          <h3 id="introTitle" class="intro-title">단단타로란?</h3>

          <div id="introContent" class="intro-read" aria-hidden="false">
            <p style='line-height:2'><strong>단단타로</strong>는 숲 스트리머 <font size=5><strong>‘다니얀’</strong></font>
              <a href="https://ch.sooplive.co.kr/daniyan1030" target="_blank" rel="noopener">
                <img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://www.sooplive.co.kr&size=16" width="20" height="20" alt="soop"></a> 님의 타로 컨텐츠에<br>
                도움이 되었으면 하는 마음에 만든 툴입니다.</p>
            <p style='line-height:2'>— <em>사용법</em><br>
              1) <span style="color:#54A9FF"><font size=4><strong>"폴더 선택"</strong></font></span>을 클릭하여 카드 이미지가 있는 폴더를 선택합니다.<br>
              선택할 경로는 <span style="color:#ff8c8c"><font size=3>카드가 뭉쳐진 폴더</font></span>를 선택하시면 됩니다.<br>
              <span style="color:#ff8c8c">폴더를 선택하지 않으면 기본 카드를 사용합니다.</span><br>
              카드 이름의 정상적용 여부는 Log 버튼 클릭 시 확인 가능<br><br>
              2) <span style="color:#54A9FF"><font size=4><strong>“다음”</strong></font></span> 클릭 후 시작합니다. 이미지가 없어도 OK <br><br>
            </p>
            <p style='line-height:2'>— <em>자세한 내용</em><br>
              빕페(네이버 카페)의 게시글 참고: <a href="https://cafe.naver.com/bver99/159313" target="_blank" rel="noopener">링크</a></p>
          </div>

          <pre id="logContent" class="intro-read" style="display:none; white-space:pre-wrap;"></pre>
        </div>
      </div>

      <!-- 오른쪽 정렬 고정 -->
      <div id="pickerRow" class="pickerRow">
        <div id="debugSlot" style="color:#a7b0bf; font-size:12px"></div>
        <div class="grow"></div>
        <span id="spin" class="spinner"></span>
        <button id="pickBtn" class="skewed" type="button">폴더선택</button>
        <button id="nextBtn" class="skewed" type="button">다음</button>
        <input id="dirInput" type="file" webkitdirectory multiple style="display:none" />
      </div>

      <div id="msg" class="center-msg">타이틀 이미지를 불러오는 중…</div>

      <div style="margin-top:6px; font-size:12px; color:#7f8aa3">
        <p>만든이 : 옳다쿠나, 본 코드는 생성형 컨텐츠(AI) 활용 프로젝트입니다.</p>
        <p>타이틀 : 도바 from 빕페 (감사합니다!) </p>
      </div>
    </div>
  </div>

  <!-- 카드 라이트박스 -->
  <div id="cardOverlay" class="veil hide">
    <div id="lightWrap" class="lightWrap" role="dialog" aria-modal="true" aria-label="Card preview">
      <img id="lightImg" class="lightImg" alt="선택 카드">
      <div id="lightCap" class="lightCap"></div>
    </div>
  </div>

<script>
  /* =========================================================
     [MIGRATED DATA] code.gs의 데이터를 여기로 옮겼습니다.
     ========================================================= */

  /** 초기 Log 텍스트 */
  const LOG_TEXT = [
    'Ver. 3.1',
    '> 대기열 레이아웃 추가.',
    '> 버튼 디자인 수정',
    '> 동영상에 프레임 추가',
    'Ver. 3',
    '> Google Apps Script에서 GitHub Pages로 이전되었습니다.',
    '> 카드 전체화면 보기 시 동영상 재생기능 추가',
    'Ver. 2.5.1',
    '> 카드 이미지 새로 생성, 버튼과 배열의 간격 일부 조정',
    'Ver. 2.5',
    '> 카드 배열 재정리, 해상도 1920x1080 기준으로 작성하였습니다',
    '> 카드 제거 기능을 버튼으로 교체 / 카드 클릭 시 확대 기능 추가',
    'Ver. 2.0',
    '> 기존 타로데이 시트 연동 기능은 정적 페이지에서 비활성화 됩니다.',
    '  이름의 흰 영역을 클릭하거나, RESET 시 해당 값 갱신',
    '> 카드 한장만 제거 기능 추가, UX개선, 연출 개선',
    '> 카드 마우스 오버 시 확대 기능 추가',
    'Ver. 1.5',
    '> 타이틀 화면 재구성 및 카드 이미지 로직 개선',
    'Ver. 1.0',
    '> 앱 최초배포',
  ].join('\n');

  function getInitialLogText() {
    return LOG_TEXT;
  }

  /** 78장 카드 메타 데이터 생성 함수 (displayName을 각 카드별로 직접 지정) */
  function getTarotDB() {
    // ✅ 메이저 카드: 여기서 displayName을 직접 수정하세요.
    const major = [
      { num:0,  eng:"The Fool",           kor:["바보", "광대"], displayName: "바보" },
      { num:1,  eng:"The Magician",       kor:["마법사"],       displayName: "마법사" },
      { num:2,  eng:"The High Priestess", kor:["여사제","고위여사제"], displayName: "여사제" },
      { num:3,  eng:"The Empress",        kor:["여제","여황제"], displayName: "여황제" },
      { num:4,  eng:"The Emperor",        kor:["황제"],         displayName: "황제" },
      { num:5,  eng:"The Hierophant",     kor:["교황"],         displayName: "교황" },
      { num:6,  eng:"The Lovers",         kor:["연인"],         displayName: "연인" },
      { num:7,  eng:"The Chariot",        kor:["전차"],         displayName: "전차" },
      { num:8,  eng:"Strength",           kor:["힘"],           displayName: "힘" },
      { num:9,  eng:"The Hermit",         kor:["은둔자"],       displayName: "은둔자" },
      { num:10, eng:"Wheel of Fortune",   kor:["운명의 수레바퀴", "운수"], displayName: "운명의 수레바퀴" },
      { num:11, eng:"Justice",            kor:["정의"],         displayName: "정의" },
      { num:12, eng:"The Hanged Man",     kor:["매달린 남자", "매달린놈"], displayName: "매달린 남자" },
      { num:13, eng:"Death",              kor:["죽음"],         displayName: "죽음" },
      { num:14, eng:"Temperance",         kor:["절제"],         displayName: "절제" },
      { num:15, eng:"The Devil",          kor:["악마"],         displayName: "악마" },
      { num:16, eng:"The Tower",          kor:["탑"],           displayName: "탑" },
      { num:17, eng:"The Star",           kor:["별"],           displayName: "별" },
      { num:18, eng:"The Moon",           kor:["달"],           displayName: "달" },
      { num:19, eng:"The Sun",            kor:["태양"],         displayName: "태양" },
      { num:20, eng:"Judgement",          kor:["심판"],         displayName: "심판" },
      { num:21, eng:"The World",          kor:["세계"],         displayName: "세계" }
    ];

    // ✅ 마이너 카드: 여기서 displayName을 직접 수정하세요.
    const minorCardNames = {
      Wands1: "완드 에이스",
      Wands2: "완드 2",
      Wands3: "완드 3",
      Wands4: "완드 4",
      Wands5: "완드 5",
      Wands6: "완드 6",
      Wands7: "완드 7",
      Wands8: "완드 8",
      Wands9: "완드 9",
      Wands10: "완드 10",
      WandsPage: "완드 페이지",
      WandsKnight: "완드 나이트",
      WandsQueen: "완드 퀸",
      WandsKing: "완드 킹",
      Cups1: "컵 에이스",
      Cups2: "컵 2",
      Cups3: "컵 3",
      Cups4: "컵 4",
      Cups5: "컵 5",
      Cups6: "컵 6",
      Cups7: "컵 7",
      Cups8: "컵 8",
      Cups9: "컵 9",
      Cups10: "컵 10",
      CupsPage: "컵 페이지",
      CupsKnight: "컵 나이트",
      CupsQueen: "컵 퀸",
      CupsKing: "컵 킹",
      Swords1: "소드 에이스",
      Swords2: "소드 2",
      Swords3: "소드 3",
      Swords4: "소드 4",
      Swords5: "소드 5",
      Swords6: "소드 6",
      Swords7: "소드 7",
      Swords8: "소드 8",
      Swords9: "소드 9",
      Swords10: "소드 10",
      SwordsPage: "소드 페이지",
      SwordsKnight: "소드 나이트",
      SwordsQueen: "소드 퀸",
      SwordsKing: "소드 킹",
      Coins1: "코인 에이스",
      Coins2: "코인 2",
      Coins3: "코인 3",
      Coins4: "코인 4",
      Coins5: "코인 5",
      Coins6: "코인 6",
      Coins7: "코인 7",
      Coins8: "코인 8",
      Coins9: "코인 9",
      Coins10: "코인 10",
      CoinsPage: "코인 페이지",
      CoinsKnight: "코인 나이트",
      CoinsQueen: "코인 퀸",
      CoinsKing: "코인 킹",
    };

    const suits = [
      { key:"Wands",  kor:"완드", alt: "지팡이" },
      { key:"Swords", kor:"소드", alt: "검" },
      { key:"Cups",   kor:"컵", alt: "잔" },
      { key:"Coins",  kor:"코인", alt: "펜타클" }
    ];
    const courts = [
      { rank:"Page",   kor:"페이지", alt: "시종" },
      { rank:"Knight", kor:"나이트", alt: "기사" },
      { rank:"Queen",  kor:"퀸", alt: "여왕" },
      { rank:"King",   kor:"킹", alt: "왕" },
    ];

    const cards = [];
    const sanitize = (str) => (str ||'').toLowerCase().replace(/\s+/g,'');

    // 메이저 22
    major.forEach(m => {
      cards.push({
        id: `M${m.num}`,
        type: "major",
        num: m.num,
        eng: m.eng,
        displayName: m.displayName, // 직접 지정된 displayName 사용
        searchKeywords: [sanitize(m.eng), ...m.kor.map(sanitize)]
      });
    });

    // 숫자 40 (각 슈트 1~10)
    for (const s of suits) {
      for (let n=1; n<=10; n++) {
        const engKey = `${s.key}${n}`;
        cards.push({
          id: `m_${s.key.toLowerCase()}_${n}`,
          type: "minor",
          suit: s.key,
          num: n,
          court: false,
          eng: engKey,
          displayName: minorCardNames[engKey] || engKey, // 맵에서 displayName 조회
          searchKeywords: [ sanitize(engKey), sanitize(`${s.kor}${n}`), sanitize(`${s.alt}${n}`) ]
        });
      }
    }

    // 궁정 16 (각 슈트 × 4)
    for (const s of suits) {
      for (const c of courts) {
        const engKey = `${s.key}${c.rank}`;
        cards.push({
          id: `m_${s.key.toLowerCase()}_${c.rank.toLowerCase()}`,
          type: "minor",
          suit: s.key,
          num: null,
          court: true,
          rank: c.rank,
          eng: `${s.key} ${c.rank}`,
          displayName: minorCardNames[engKey] || `${s.alt} ${c.alt}`, // 맵에서 displayName 조회
          searchKeywords: [
            sanitize(engKey),
            sanitize(c.rank),
            sanitize(c.kor),
            sanitize(c.alt),
            sanitize(`${s.kor}${c.kor}`),
            sanitize(`${s.kor}${c.alt}`),
            sanitize(`${s.alt}${c.kor}`),
            sanitize(`${s.alt}${c.alt}`)
          ]
        });
      }
    }
    return cards;
  }

  /* =========================================================
     ✅ Google Apps Script Web App URL
     - api.gs.txt 파일 배포 후 생성된 URL을 여기에 붙여넣으세요.
     ========================================================= */
  const GAS_API_URL = 'https://script.google.com/macros/s/AKfycbyAcnbEtX81fDYFfRUt1hYBvdD7w2YNlHwSD9WBRox2XX8d02sgkY7dujzn0ebLyCrz3g/exec';

  /* =========================================================
     ✅ 앱 전체 기준 폭 (여기 값만 바꾸면 전부 재계산)
     - 컨트롤 2줄 가운데 정렬 / 카드 그리드 / 메모 펼침 폭
     예) 1400 → 1920 변경 시, 1920 기준으로 재배치
     ========================================================= */
  const APP_WIDTH = 1400;

  /* =========================================================
     ✅ 전체화면(라이트박스) 배율/캡션 스케일 조정 포인트
     ========================================================= */
  const FS_MAX_VW = 0.9;
  const FS_MAX_VH = 0.9;
  const FS_CAPTION_H = 80;
  const FS_BASE_IMG_W = 80;

  /* =========================================================
     ✅ (추가) 라이트박스 비디오 반복재생 딜레이 (ms)
     ========================================================= */
  const VIDEO_LOOP_DELAY = 1500;


  /* =========================================================
     ✅ (추가) 메모장 세로 높이 직접 조정 지점
     ========================================================= */
  const MEMO_MIN_HEIGHT_PX = 720;

  const TITLE_URL = './title.png';
  const PLACEHOLDER = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';

  let ALL_CARDS = [], IMAGE_MAP = {}, VIDEO_MAP = {}, selected = null, picked = [];
  let pickedSet = new Set();

  /* 기준 폭과 메모 높이를 CSS 변수로 반영 */
  document.documentElement.style.setProperty('--APP_WIDTH', APP_WIDTH + 'px');
  document.documentElement.style.setProperty('--MEMO_MIN_H', MEMO_MIN_HEIGHT_PX + 'px');

  // DOM refs
  const elSearch = document.getElementById('search');
  const elDrop   = document.getElementById('dropdown');
  const elDecide = document.getElementById('decideBtn');
  const elReset  = document.getElementById('resetBtn');
  const elBoard  = document.getElementById('board');
  const elRev    = document.getElementById('rev');
  const flipThumb= document.getElementById('flipThumb');
  const elMemo   = document.getElementById('memo');
  const elMemoToggle = document.getElementById('memoToggle');

  const elTitleImg = document.getElementById('titleImg');
  const elPick = document.getElementById('pickBtn');
  const elNext = document.getElementById('nextBtn');
  const elDir  = document.getElementById('dirInput');
  const elMsg  = document.getElementById('msg');
  const elSpin = document.getElementById('spin');
  const elDebugSlot = document.getElementById('debugSlot');
  const elReadFlip = document.getElementById('readFlip');
  const elReadThumb= document.getElementById('readThumb');
  const elIntro = document.getElementById('introContent');
  const elLog   = document.getElementById('logContent');
  
  // New DOM ref for queueCurrentCount
  const elQueueCurrentCount = document.getElementById('queueCurrentCount');

  // 상태 패널 refs
  const elStatusBox = document.getElementById('statusBox');
  const elStatusVal = document.getElementById('statusVal');
  const elStatusSpin= document.getElementById('statusSpinner');
  const elQueueSpin = document.getElementById('queueSpinner'); // 추가

  // 라이트박스
  const overlay   = document.getElementById('cardOverlay');
  const lightWrap = document.getElementById('lightWrap');
  const lightImg  = document.getElementById('lightImg');
  const lightCap  = document.getElementById('lightCap');

  /* ====== "현재:" 패널 (GAS API 연동) ====== */
  function statusLoading(on){ 
    elStatusSpin.classList.toggle('on', !!on); 
    if(elQueueSpin) elQueueSpin.classList.toggle('on', !!on); // 대기열 스피너 토글
  }
  
  function statusShowValues(c6, d6, queueCount, isAnyClosed){ // isAnyClosed 파라미터 추가
    const safeC6 = String(c6 || '').trim();
    const safeD6 = String(d6 || '').trim();
    const rawText = safeC6 + safeD6;
    
    // 특수문자/공백 제거하고 한글/영문/숫자만 남김
    // 그리고 그 결과가 정확히 '마감'인지 확인 (현재 진행 중인 건)
    const cleaned = rawText.replace(/[^가-힣a-zA-Z0-9]/g, '');
    const isCurrentClosed = (cleaned === '마감');
    
    // 대기열 전체 마감 여부 (현재 건이 마감이거나, 리스트 중 마감이 있는 경우)
    const isQueueClosed = isCurrentClosed || isAnyClosed;
    
    const count = (typeof queueCount === 'number') ? queueCount : 0;
    
    // elStatusVal (현재:) 처리 - c6, d6 배지 형태로 항상 표시 (이전 상태 복원)
    // 단, 현재 건 자체가 마감이면 [마감] 표시
    let statusValHtml = '';
    if (isCurrentClosed) { 
      statusValHtml = '<span class="badge-closed">마감</span>';
    } else {
      if (safeC6) statusValHtml += `<span class="status-badge">${safeC6}</span>`;
      if (safeD6) statusValHtml += `<span class="status-badge">${safeD6}</span>`;
      if (!statusValHtml) statusValHtml = '<span class="status-badge" style="opacity:0.5; min-width: 1.5em;">&nbsp;</span>'; 
    }
    elStatusVal.innerHTML = statusValHtml;


    // elQueueCurrentCount (현재 대기열:) 처리 - 마감 로직 + 인원수 로직
    let queueCountHtml = '';
    if (isQueueClosed) { // 전체 중 하나라도 마감이면 마감 로직 적용
      if (count >= 2) {
        // 마감이고 2명 이상이면 인원수 + 마감 배지
        queueCountHtml = `<span class="status-badge">${count} 명</span> <span class="badge-closed">마감</span>`;
      } else {
        // 마감이고 1명 이하이면 마감 배지만
        queueCountHtml = '<span class="badge-closed">마감</span>';
      }
    } else {
      // 마감이 아니면 'n 명' 형태로 표시
      queueCountHtml = `<span class="status-badge">${count} 명</span>`;
    }
    
    if (elQueueCurrentCount) {
       elQueueCurrentCount.innerHTML = queueCountHtml;
    }
  }

  // 대기열 테이블 렌더링 함수
  function renderQueueTable(queueData, totalCount) {
    const tbody = document.getElementById('queueTableBody');
    if (!tbody) return;
    
    let html = queueData.map((item, index) => {
      const rank = index + 1;
      // 안전하게 문자열로 변환
      const nick = String(item.nick || '');
      const type = String(item.type || ''); 

      // '마감' 여부 확인 (문자열로 변환된 값 사용)
      // 닉네임과 타로종류를 합쳐서 특수문자 제거 후 정확히 '마감'만 남는지 확인
      // 예: '마/감' -> '마감' (O), '마감감마' -> '마감감마' (X)
      const combinedText = (nick + type).replace(/[^가-힣a-zA-Z0-9]/g, '');
      const isClosed = (combinedText === '마감');

      if (isClosed) {
        return `
          <tr>
            <td>${rank}</td>
            <td colspan="2" style="text-align: center; vertical-align: middle;">
              <span class="badge-closed">마감</span>
            </td>
          </tr>
        `;
      } else {
        return `
          <tr>
            <td>${rank}</td>
            <td>${nick || '-'}</td>
            <td>${type}</td>
          </tr>
        `;
      }
    }).join('');



    tbody.innerHTML = html;
  }
  
  function refreshStatus(){
    const placeholderUrl = '';
    if (!GAS_API_URL || GAS_API_URL === placeholderUrl) {
      statusShowValues("API 주소 필요", "");
      console.warn(`index.html의 GAS_API_URL 상수에 배포된 웹 앱의 URL을 입력해주세요.`);
      return;
    }

    statusLoading(true);

    // 1. 고유한 콜백 함수 이름을 생성합니다.
    const callbackName = 'jsonp_callback_' + Math.round(100000 * Math.random());
    
    // 2. API가 호출할 전역 콜백 함수를 window 객체에 정의합니다.
    window[callbackName] = function(data) {
        // 4. API 호출이 끝나면, 생성했던 스크립트 태그와 전역 함수를 정리합니다.
        document.body.removeChild(script);
        delete window[callbackName];
        
        // 5. 가져온 데이터를 처리합니다.
        if (data.success) {
            // 전체 대기열 중 하나라도 '마감'이 있는지 확인
            let isAnyClosed = false;
            if (data.queue && Array.isArray(data.queue)) {
                isAnyClosed = data.queue.some(item => {
                    const combined = (item.nick || '') + (item.type || '');
                    const cleaned = combined.replace(/[^가-힣a-zA-Z0-9]/g, '');
                    return cleaned === '마감';
                });
            }

            statusShowValues(data.c6, data.d6, data.queueCount, isAnyClosed); // isAnyClosed 추가 전달
            
            // 대기열 테이블 렌더링 (API가 queue 배열을 반환한다고 가정)
            if (data.queue && Array.isArray(data.queue)) {
                renderQueueTable(data.queue, data.queueCount); // totalCount 추가 전달
            }
        } else {
            console.error('Error from GAS API:', data.error);
            statusShowValues("API 오류", "");
        }
        statusLoading(false);
    };

    // 3. 동적으로 <script> 태그를 생성하여 API를 호출합니다.
    // URL에 `callback=콜백함수이름` 파라미터를 추가합니다.
    const script = document.createElement('script');
    script.src = GAS_API_URL + (GAS_API_URL.includes('?') ? '&' : '?') + 'callback=' + callbackName;
    
    // 타임아웃 또는 네트워크 오류 처리
    script.onerror = function() {
        document.body.removeChild(script);
        delete window[callbackName];
        console.error('Error fetching status from GAS API via JSONP.');
        statusShowValues("연결 실패", "");
        statusLoading(false);
    };

    document.body.appendChild(script);
  }
  elStatusBox.addEventListener('click', refreshStatus); // 클릭으로 갱신

  /* 소개글/Log 토글 */
  function setReadMode(isLog){
    elReadThumb.textContent = isLog ? 'Log' : '소개글';
    elIntro.style.display   = isLog ? 'none' : 'block';
    elIntro.setAttribute('aria-hidden', isLog ? 'true' : 'false');
    elLog.style.display     = isLog ? 'block' : 'none';
    elLog.setAttribute('aria-hidden', isLog ? 'false' : 'true');
    document.getElementById('introTitle').textContent = isLog ? 'Log' : '단단타로란?';
  }
  elReadFlip.addEventListener('change', ()=> setReadMode(elReadFlip.checked));
  setReadMode(false);

  /* 초기 Log 텍스트 로드 (동기 처리로 변경) */
  elLog.textContent = getInitialLogText();


  /* 타이틀 이미지 */
  (function initTitle(){
    elTitleImg.src = PLACEHOLDER;
    const test = new Image();
    test.onload  = () => { elTitleImg.src = TITLE_URL; elMsg.textContent=''; };
    test.onerror = () => { elMsg.textContent = '타이틀 이미지 로드 실패'; };
    test.src = TITLE_URL;
  })();

  let folderSelected = false; // 폴더 선택 여부 플래그

  // 기본 이미지 맵 생성 헬퍼
  function getDefaultImageMap() {
    const map = {};
    for (const card of ALL_CARDS) {
        const filename = expectedFilenameForCard(card);
        map[cardId(card)] = `./assets/img/${filename}`;
    }
    return map;
  }

  // "다음" 버튼 로직 수정
  elNext.addEventListener('click', ()=> {
    if (!folderSelected) {
        IMAGE_MAP = getDefaultImageMap();
        elMsg.textContent = '기본 이미지 세트를 사용합니다.';
    }
    document.getElementById('veil').classList.add('hide');
  });


  /* 카드 식별/파일명 */
  const MAJOR_NAME_MAP = {
    0:'Fool', 1:'Magician', 2:'HighPriestess', 3:'Empress', 4:'Emperor',
    5:'Hierophant', 6:'Lovers', 7:'Chariot', 8:'Strength', 9:'Hermit',
    10:'WheelofFortune', 11:'Justice', 12:'HangedMan', 13:'Death',
    14:'Temperance', 15:'Devil', 16:'Tower', 17:'Star', 18:'Moon',
    19:'Sun', 20:'Judgement', 21:'World'
  };
  const cardId = c => c?.id || c?.eng;
  const expectedFilenameForCard = c => (
    c.type==='major' ? `${MAJOR_NAME_MAP[c.num]}.png`
      : (!c.court ? `${c.suit}${String(c.num).padStart(2,'0')}.png` : `${c.suit}${c.rank}.png`)
  );

  /* 폴더 선택(webkitdirectory) + 로그 (수정됨) */
  elPick.addEventListener('click', ()=> elDir.click());
  elDir.addEventListener('change', async (e)=>{
    if (!e.target.files?.length) return;

    folderSelected = true;
    document.getElementById('viewAllCardsBtn').style.display = 'none';
    elSpin.classList.add('on');
    elMsg.textContent='폴더 스캔 중 — img/ 및 vid/ 폴더를 확인합니다…';

    try {
        const scanResult = await scanUserFolder(e.target.files);
        IMAGE_MAP = scanResult.imageMap;
        VIDEO_MAP = scanResult.videoMap;

        applyScanResult(scanResult);
        updateLogAfterScan(scanResult);
    } finally {
        elSpin.classList.remove('on');
        e.target.value = ''; // 다음 선택을 위해 초기화
    }
  });

  // 스캔 및 병합 로직 (신규)
  async function scanUserFolder(fileList) {
    const userFiles = Array.from(fileList);
    
    // webkitRelativePath가 '폴더명/img/파일.png' 형태이므로 정규식으로 안전하게 추출
    const imgFiles = userFiles.filter(f => /[\/\\]img[\/\\]/i.test(f.webkitRelativePath) && /\.(png|jpg|jpeg)$/i.test(f.name));
    const vidFiles = userFiles.filter(f => /[\/\\]vid[\/\\]/i.test(f.webkitRelativePath) && /\.webm$/i.test(f.name));

    const finalImageMap = getDefaultImageMap(); // 1. 기본 이미지로 시작
    const finalVideoMap = {};

    let userImgMatchedCount = 0;
    let userVidMatchedCount = 0;

    // 카드 이름을 파일명과 매칭하기 위한 맵 (빠른 탐색용)
    const cardByFileName = ALL_CARDS.reduce((acc, card) => {
        const fileName = expectedFilenameForCard(card);
        acc[fileName] = card;
        return acc;
    }, {});

    // 2. 사용자 이미지 덮어쓰기
    for (const file of imgFiles) {
        const card = cardByFileName[file.name];
        if (card) {
            finalImageMap[cardId(card)] = URL.createObjectURL(file);
            userImgMatchedCount++;
        }
    }

    // 3. 사용자 비디오 매칭
    for (const file of vidFiles) {
        const videoNameBase = file.name.replace(/\.webm$/i, '');
        // 비디오 파일명 (예: 'Strength.webm')과 일치하는 카드를 찾음
        const card = ALL_CARDS.find(c => expectedFilenameForCard(c).replace(/\.png$/i, '') === videoNameBase);
        if (card) {
            finalVideoMap[cardId(card)] = URL.createObjectURL(file);
            userVidMatchedCount++;
        }
    }

    const expectedImgNames = ALL_CARDS.map(expectedFilenameForCard);
    const userImgNames = imgFiles.map(f => f.name);
    const missingImgs = expectedImgNames.filter(name => !userImgNames.includes(name));
    const extraImgs = userImgNames.filter(name => !expectedImgNames.includes(name));
    
    const expectedVidNames = ALL_CARDS.map(c => expectedFilenameForCard(c).replace(/\.png$/, '.webm'));
    const userVidNames = vidFiles.map(f => f.name);
    const extraVids = userVidNames.filter(name => !expectedVidNames.includes(name));


    return {
        imageMap: finalImageMap,
        videoMap: finalVideoMap,
        imgMapped: userImgMatchedCount,
        vidMapped: userVidMatchedCount,
        total: ALL_CARDS.length,
        missing: missingImgs,
        imgExtras: extraImgs,
        vidExtras: extraVids,
        imgFileCount: imgFiles.length,
        vidFileCount: vidFiles.length
    };
  }

  // 스캔 결과 적용 UI (수정됨)
  function applyScanResult({imgMapped,vidMapped,total,missing,imgExtras}){
    if (imgMapped === 0) {
        elMsg.textContent = '선택한 폴더의 img/ 하위 폴더에 매칭된 이미지가 없습니다. 기본 이미지를 사용합니다.';
    } else if (imgMapped < total) {
        elMsg.textContent = `사용자 이미지 ${imgMapped}개 + 기본 이미지 ${total - imgMapped}개를 사용합니다.`;
    } else {
        elMsg.textContent = '모든 카드가 사용자 이미지와 매칭되었습니다!';
    }
    
    if (vidMapped > 0) {
      elMsg.textContent += ` (커스텀 비디오 ${vidMapped}개 포함)`;
    }

    const parts = [];
    if (missing.length) parts.push(`이미지 누락 ${missing.length}개`);
    if (imgExtras.length)  parts.push(`여분 이미지 ${imgExtras.length}개`);
    elDebugSlot.textContent = parts.join(' · ');
  }

  // 로그 업데이트 UI (수정됨)
  function updateLogAfterScan({imgMapped, vidMapped, total, missing, imgExtras, vidExtras, imgFileCount, vidFileCount}){
    const now = new Date();
    const header =
      `# 단단타로 — 폴더 검사 결과\n` +
      `시각: ${now.toLocaleString('ko-KR')}\n` +
      `선택 폴더 내 'img' 폴더의 .png/.jpg 파일 수: ${imgFileCount}\n` +
      `선택 폴더 내 'vid' 폴더의 .webm 파일 수: ${vidFileCount}\n` +
      `\n[이미지 매칭 결과]\n` +
      `매칭된 사용자 이미지: ${imgMapped} / ${total}\n` +
      `${total - imgMapped}개는 ./assets/img/ 의 기본 이미지로 대체됩니다.\n` +
      `\n[비디오 매칭 결과]\n` +
      `매칭된 사용자 비디오: ${vidMapped}개`;

    const tip =
      `\n\n※ 참고: 선택한 폴더 바로 아래에 'img', 'vid' 폴더가 있어야 합니다.\n` +
      `   파일명은 규칙과 대소문자까지 일치해야 합니다.\n` +
      `   이미지: (폴더)/img/Wands01.png\n`+ 
      `   비디오: (폴더)/vid/Wands01.webm\n`;
    
    const missBlock  = missing.length ? `\n[이미지 누락(기본값 사용) ${missing.length}개]\n- ` + missing.join('\n- ') : ``;
    const imgExtraBlock = imgExtras.length  ? `\n\n[여분 이미지(규칙 밖) ${imgExtras.length}개]\n- ` + imgExtras.join('\n- ') : ``;
    const vidExtraBlock = vidExtras.length  ? `\n\n[여분 비디오(규칙 밖) ${vidExtras.length}개]\n- ` + vidExtras.join('\n- ') : ``;
    
    elLog.textContent = header + tip + missBlock + imgExtraBlock + vidExtraBlock;
    elLog.dataset.hasScan = '1';
  }

  /* 정/역 라벨 */
  function syncFlip(){ flipThumb.textContent = elRev.checked ? '역방향' : '정방향'; }
  syncFlip();
  elRev.addEventListener('change', syncFlip);

  /* ===== 보드 렌더 (수정됨) ===== */
  function renderBoard(){
    elBoard.innerHTML = picked.map((c, idx)=>{
      const url   = IMAGE_MAP[cardId(c)] || '';
      const displayName = c.displayName || c.eng;
      const revCls = c.reversed ? ' rev' : '';
      const hasImg = url ? ' has-img' : '';

      return `
        <div class="cardItem" data-idx="${idx}" title="${displayName}">
          <div class="cardBox">
            <div class="card${revCls}${hasImg}"
                style="${url ? `background-image:url('${url}')` : ''}"
                aria-label="${displayName}"></div>
            <div class="cap-row">
              <div class="cap" title="${displayName}">${displayName}</div>
              <button class="remove" title="카드 제거">
                <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
              </button>
            </div>
          </div>
        </div>`;
    }).join('');
  }
  function setDecide(on){ on ? elDecide.removeAttribute('disabled') : elDecide.setAttribute('disabled','true'); }
  function updateReset(){ picked.length ? elReset.removeAttribute('disabled') : elReset.setAttribute('disabled','true'); }

  /* ===== 라이트박스 (수정됨) ===== */
  function sizeLightbox(){
    const vw = Math.min(window.innerWidth,  document.documentElement.clientWidth  || window.innerWidth);
    const vh = Math.min(window.innerHeight, document.documentElement.clientHeight || window.innerHeight);
    const maxW = vw * FS_MAX_VW, maxH = vh * FS_MAX_VH, aspect = 5/8;

    let imgW = maxW, imgH = imgW / aspect;
    if (imgH + FS_CAPTION_H > maxH) { imgH = maxH - FS_CAPTION_H; imgW = imgH * aspect; }

    lightWrap.style.width  = `${Math.floor(imgW)}px`;
    lightWrap.style.height = `${Math.floor(imgH + FS_CAPTION_H)}px`;
    
    const mediaElement = lightWrap.querySelector('video.lightImg') || lightImg;
    if (mediaElement) {
        mediaElement.style.height = `${Math.floor(imgH)}px`;
    }

    const scale = Math.max(0.75, Math.min(1.8, imgW / FS_BASE_IMG_W));
    lightWrap.style.setProperty('--fs-scale', scale.toFixed(3));
  }
  function openFullscreen(card){
    // 이전에 생성된 비디오/이미지 정리
    const oldMedia = lightWrap.querySelector('video.lightImg');
    if (oldMedia) { oldMedia.remove(); }
    lightImg.style.display = 'none';
    lightImg.src = PLACEHOLDER;

    const cardIdValue = cardId(card);
    const displayName = card.displayName || card.eng;
    lightCap.textContent = displayName + (card.reversed ? ' (역방향)' : '');

    const imageUrl = IMAGE_MAP[cardIdValue] || '';
    const isCustomImage = imageUrl.startsWith('blob:');

    let mediaUrl;
    let isVideo = false;

    if (isCustomImage) {
        // 이 카드가 사용자 정의 이미지일 경우: 사용자 정의 비디오를 찾고, 없으면 이 이미지로 대체합니다.
        mediaUrl = VIDEO_MAP[cardIdValue];
        if (mediaUrl) {
            isVideo = true;
        } else {
            mediaUrl = imageUrl; // 비디오가 없으므로 이미지 URL을 사용합니다.
            isVideo = false;
        }
    } else {
        // 이 카드가 기본 이미지일 경우: 기본 비디오를 재생합니다.
        const cardFileNameBase = expectedFilenameForCard(card).replace(/\.png$/, '');
        mediaUrl = `./assets/vid/${cardFileNameBase}.webm`;
        isVideo = true;
    }

    if (isVideo) {
        const video = document.createElement('video');
        video.className = 'lightImg';
        video.style.transform = card.reversed ? 'rotate(180deg)' : 'none';
        video.muted = true;
        video.loop = true;
        video.autoplay = true;
        video.controls = false;
        video.setAttribute('playsinline', '');
        video.src = mediaUrl;

        // 비디오 자동 재생 시작
        video.play().catch(e => console.warn("Autoplay was prevented:", e));

        // 비디오 로드 실패 시, (기본 또는 사용자) 이미지로 대체
        video.onerror = function() {
            console.log(`비디오 로드 실패: ${mediaUrl}. 이미지로 대체합니다.`);
            this.remove();
            lightImg.src = imageUrl; // 항상 해당 카드의 이미지 URL을 사용
            lightImg.style.transform = card.reversed ? 'rotate(180deg)' : 'none';
            lightImg.style.display = 'block';
        };
        
        lightWrap.insertBefore(video, lightImg);
    } else {
        // 비디오가 아닌 경우 (사용자 이미지만 있고 비디오는 없는 경우)
        lightImg.src = mediaUrl;
        lightImg.style.transform = card.reversed ? 'rotate(180deg)' : 'none';
        lightImg.style.display = 'block';
    }

    sizeLightbox();
    overlay.classList.remove('hide');
  }
  overlay.addEventListener('click', ()=> overlay.classList.add('hide'));
  // 라이트박스 내부 요소 클릭 시 오버레이 닫힘 방지
  lightWrap.addEventListener('click', (event) => {
    event.stopPropagation();
  });
  window.addEventListener('resize', ()=> { if(!overlay.classList.contains('hide')) sizeLightbox(); });

  // 카드 클릭 → 전체화면 / 삭제
  elBoard.addEventListener('click', (e)=>{
    const item = e.target.closest('.cardItem'); if(!item) return;
    const idx = Number(item.dataset.idx); if(Number.isNaN(idx)) return;

    if (e.target.closest('.remove')) {
      const removed = picked[idx];
      picked.splice(idx,1);
      pickedSet.delete(cardId(removed));
      renderBoard(); updateReset();
      return;
    }
    if (e.target.closest('.card') || e.target.closest('.cap-row') || e.target.closest('.cardBox')) {
      openFullscreen(picked[idx]);
    }
  });

  /* 검색/결정/리셋 (수정됨) */
  function runSearch(){
    const qRaw = elSearch.value.trim();
    selected = null;
    setDecide(false);

    if(!qRaw){
      elDrop.classList.remove('show');
      elDrop.innerHTML='';
      return;
    }

    const q = qRaw.toLowerCase().replace(/\s+/g,'');
    const hits = ALL_CARDS.filter(c=>{
      if(pickedSet.has(cardId(c))) return false; // 이미 배치된 카드 제외
      return c.searchKeywords.some(kw => kw.includes(q));
    }).slice(0,60);

    if(!hits.length){
      elDrop.classList.remove('show');
      elDrop.innerHTML='';
      return;
    }
    elDrop.innerHTML = hits.map((c,i)=> 
      `<div class="opt${i===0?' active':''}" data-id="${cardId(c)}">
         <span>${c.displayName}</span><small>${c.eng}</small>
       </div>`
    ).join('');
    elDrop.classList.add('show');
  }
  elSearch.addEventListener('input', runSearch);
  elDrop.addEventListener('click', e=>{
    const opt=e.target.closest('.opt'); if(!opt) return;
    const cid = opt.dataset.id;
    const cand = ALL_CARDS.find(c=>cardId(c)===cid) || null;
    if(cand && pickedSet.has(cardId(cand))) return;
    selected = cand;
    elSearch.value = selected ? selected.displayName : ''; // 노출 이름으로 input 값 설정
    elDrop.classList.remove('show');
    setDecide(!!selected);
  });

  // [추가] 검색창 키보드 탐색(위/아래/엔터/ESC)
  elSearch.addEventListener('keydown', e => {
    if (!elDrop.classList.contains('show')) return;

    const options = Array.from(elDrop.querySelectorAll('.opt:not(.disabled)'));
    if (options.length === 0) return;

    switch (e.key) {
      case 'ArrowDown':
      case 'ArrowUp': {
        e.preventDefault();
        let currentIndex = options.findIndex(opt => opt.classList.contains('active'));
        
        options[currentIndex]?.classList.remove('active');

        if (e.key === 'ArrowDown') {
          currentIndex = (currentIndex + 1) % options.length;
        } else {
          currentIndex = (currentIndex - 1 + options.length) % options.length;
        }
        
        options[currentIndex].classList.add('active');
        options[currentIndex].scrollIntoView({ block: 'nearest' });
        break;
      }

      case 'Enter': {
        e.preventDefault();
        const activeOption = elDrop.querySelector('.opt.active');
        activeOption?.click(); // 기존 클릭 로직 재사용
        break;
      }

      case 'Escape': {
        elSearch.value = '';
        elDrop.classList.remove('show');
        selected = null;
        setDecide(false);
        break;
      }
    }
  });

  document.addEventListener('click', e=>{ if(!e.target.closest('.search-wrap')) elDrop.classList.remove('show'); });

  elDecide.addEventListener('click', ()=>{
    if(!selected) return;
    const cid = cardId(selected);
    if(pickedSet.has(cid)) { setDecide(false); return; }
    picked.push({...selected, reversed: elRev.checked});
    pickedSet.add(cid);
    renderBoard(); updateReset();
    selected = null; elSearch.value=''; setDecide(false);
  });

  elReset.addEventListener('click', ()=>{
    picked = []; pickedSet.clear(); selected=null; elSearch.value=''; elDrop.classList.remove('show'); elRev.checked=false; syncFlip(); renderBoard(); updateReset();
    refreshStatus(); // RESET 시 시트값 갱신
  });

  /* 메모 토글 → 보드 폭 재계산 (열 너비 0/420px 전환) */
  function syncMemoLayout(){
    const col = elMemo.classList.contains('collapsed') ? '0px' : '420px';
    document.documentElement.style.setProperty('--MEMO_COL', col);
  }
  elMemoToggle.addEventListener('click', ()=>{
    const willHide = !elMemo.classList.contains('collapsed');
    elMemo.classList.toggle('collapsed', willHide);
    elMemoToggle.textContent = willHide ? '메모장 열기' : '메모장 닫기';
    elMemoToggle.setAttribute('aria-pressed', willHide ? 'true' : 'false');
    syncMemoLayout();
  });
  syncMemoLayout(); // 초기(접힘) 상태 반영

  // 초기 DB 로드 (수정됨)
  (function init(){
    ALL_CARDS = getTarotDB();
    // IMAGE_MAP은 "다음" 또는 "폴더 선택" 시점에 초기화되므로 여기서는 비워둡니다.
    refreshStatus(); // 시트값 갱신은 그대로 호출
  })();

  // 우클릭 방지
  document.addEventListener('contextmenu', event => event.preventDefault());

  // F12 개발자 도구 방지
  document.addEventListener('keydown', function(event) {
    if (event.keyCode === 123) { // F12 key
        event.preventDefault();
    }
  });

  /* =========================================================
     ✅ 대기열 설정 (Queue Settings) 로직 - 통합 크기 조절 (Scale) & 위치 이동
     ========================================================= */
  (function initQueueSettings(){
    const STORAGE_KEY = 'dandan_queue_config_v6_pos'; // 키 변경 (초기화 v6)
    
    // DOM Elements
    const box = document.getElementById('queueBox');
    const btnSet = document.getElementById('queueSettingBtn');
    const btnPos = document.getElementById('queuePosBtn'); // 위치 버튼
    const popup = document.getElementById('queueSettings');
    
    // Controls (Single Scale)
    const btnMinus = document.getElementById('qsScaleMinus');
    const btnPlus  = document.getElementById('qsScalePlus');
    const txtVal   = document.getElementById('qsScaleVal');

    // Helper to read CSS variable
    const getCssVar = (name, fallback) => {
      const val = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
      return val ? parseInt(val, 10) : fallback;
    };

    // Base Values (기본값)
    const BASE_W = getCssVar('--queue-width', 280);
    const BASE_H = getCssVar('--queue-height', 300);
    const BASE_F = getCssVar('--queue-font-base', 15);

    // Step Units (증감 단위)
    const UNIT_W = getCssVar('--step-width', 30);
    const UNIT_H = getCssVar('--step-height', 40);
    const UNIT_F = getCssVar('--step-font-size', 2);

    // 0: BL, 1: TL
    const POSITIONS = ['pos-bl', 'pos-tl']; // 순환 경로에서 pos-br 제거
    const config = {
      step: 0,
      pos: 0 
    };

    // 1. Load & Apply
    function loadConfig(){
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if(saved) {
          const parsed = JSON.parse(saved);
          if (typeof parsed.step === 'number') config.step = parsed.step;
          // 저장된 pos가 유효한 범위 내에 있는지 확인
          if (typeof parsed.pos === 'number' && parsed.pos >= 0 && parsed.pos < POSITIONS.length) {
            config.pos = parsed.pos;
          }
        }
      } catch(e){ console.warn('Settings load failed', e); }
      applyConfig();
    }

    function applyConfig(){
      const s = config.step;

      // 값 계산
      const currW = BASE_W + (s * UNIT_W);
      const currH = BASE_H + (s * UNIT_H);
      const currF = BASE_F + (s * UNIT_F);

      // CSS 적용
      const root = document.documentElement;
      root.style.setProperty('--queue-width', currW + 'px');
      root.style.setProperty('--queue-height', currH + 'px');
      
      // 폰트 관련 변수 일괄 업데이트
      root.style.setProperty('--queue-font-base', currF + 'px');
      root.style.setProperty('--queue-title-font-size', (currF + 5) + 'px');
      root.style.setProperty('--queue-status-font-size', (currF + 3) + 'px');
      root.style.setProperty('--queue-table-header-font-size', currF + 'px');
      
      // 텍스트 표시 업데이트
      txtVal.textContent = formatStep(s);

      // 위치 적용
      updatePositionClass();
    }

    function updatePositionClass() {
      box.classList.remove('pos-bl', 'pos-tl', 'pos-tr', 'pos-br'); // 모든 클래스 제거
      box.classList.add(POSITIONS[config.pos]); // 새 위치 클래스 추가
    }

    function formatStep(val) {
      if (val === 0) return '기본';
      return val > 0 ? `+${val}` : `${val}`;
    }

    function saveConfig(){
      localStorage.setItem(STORAGE_KEY, JSON.stringify(config));
    }

    function updateStep(delta) {
      const newVal = config.step + delta;
      // 0(기본) ~ 5(+5) 범위로 제한
      if (newVal >= 0 && newVal <= 5) {
        config.step = newVal;
        applyConfig();
        saveConfig();
      }
    }

    // 2. Events
    // Toggle Popup
    btnSet.addEventListener('click', (e) => {
      e.stopPropagation();
      popup.classList.toggle('show');
    });

    // Position Toggle
    if(btnPos) {
      btnPos.addEventListener('click', (e) => {
        e.stopPropagation();
        config.pos = (config.pos + 1) % POSITIONS.length; // POSITIONS 배열 길이에 맞춰 순환
        applyConfig();
        saveConfig();
      });
    }

    // Close when clicking outside
    document.addEventListener('click', (e) => {
      if(!box.contains(e.target)) popup.classList.remove('show');
    });
    popup.addEventListener('click', e => e.stopPropagation());

    // Scale Control
    btnMinus.addEventListener('click', () => updateStep(-1));
    btnPlus.addEventListener('click',  () => updateStep(1));

    // Init
    loadConfig();
  })();
</script>
</body>
</html>